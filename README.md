### 알고리즘이란 ? (알고리즘, algorithm)
* 어떤 문제를 풀기 위한 절차/방법
* 어떤 문제에 대해 특정한 '입력'을 넣으면, 원하는 '출력'을 얻을 수 있도록 만든 프로그래밍

### 자료구조와 알고리즘이 중요한 이유
* 어떤 자료구조와 알고리즘을 쓰냐에 따라, 성능의 차이가 크다
- - -
## Sorting
어떤 데이터가 주어졌을 때 순서대로 나열하는 것

### Bubble Sort
두 인접한 데이터를 비교 후, 앞 > 뒤 조건에 만족할 때 위치를 바꾸는 알고리즘 <- 처음부터 끝까지 이를 반복<br>
눈으로 보는 원리 : https://visualgo.net/en/sorting 

**분석**
반복문이 2개 이므로 보통 : O(n^2)<br>
구체적으로 계산하면 : n * (n-1) / 2<br>
완전 정렬이 되어있을 경우 : O(n)
- - -
### Selection Sort
다음을 반복하여 수행
1. 데이터 중 최소값을 찾은 후 가장 앞에 위치한 값과 교체
2. 다시 최소값을 찾은 후 앞의 (1)과정에서 찾은 값을 제외 후 앞에 위치한 값과 교체<br>
눈으로 보는 원리 : https://visualgo.net/en/sorting

**분석**
반복문이 2개 이므로 보통 : O(n^2)<br>
구체적으로 계산하면 : n * (n-1) / 2<br>
완전 정렬이 되어있을 경우 : O(n)
- - -
### Insertion Sort
두번째 인덱스 부터 시작하며 먼저 값을 복사 후 앞에 위치한 값들과 비교 후 낮으면 해당 위치로 이동<br>
눈으로 보는 원리 : https://visualgo.net/en/sorting

**분석**
반복문이 2개 이므로 보통 : O(n^2)<br>
구체적으로 계산하면 : n * (n-1) / 2<br>
완전 정렬이 되어있을 경우 : O(n)
- - -
### Recursive Call (재귀 함수, 재귀 용법)
함수 안에서 동일한 함수를 호출하는 형태

**예제1. Factorial - 시간 복잡도와 공간 복잡도**
* Factorial(n)은 (n - 1)번의 factorial() 함수를 호출하여 곱셈을 한다.
  * 일종의 (n-1)번의 반복문을 호출 하는 것과 동일하다.
  * factorial() 함수를 호출할 때마다, n 개의 지역변수가 생성된다.
* 시간, 공간 복잡도는 O(n-1)이므로, 여기서 상수를 제외하면 O(n) 이 된다.

**예제2. 1부터 n 까지의 곱을 출력되게 만들기**

**예제3. 숫자가 들어 있는 리스트가 주어졌을 때, 리스트의 합을 리턴하는 함수 만들기**

**예제4. palindrome(회문)을 판별하는 함수 만들기**<br>
palindrome이란, 앞으로 읽으나 거꾸로 읽으나 동일한 단어 또는 구

**예제5. 정수 n에 대하여, n이 홀수이면 3 X n + 1 을 하고 n이 짝수이면 n / 2를 한다. 이렇게 계속 진행하여 n 이 결국 1 이 될 때까지 반복한다.예제5. 정수 n에 대하여, n이 홀수이면 3 X n + 1 을 하고 n이 짝수이면 n / 2를 한다. 이렇게 계속 진행하여 n 이 결국 1 이 될 때까지 반복한다.**

**예제6. 정수 4를 1, 2, 3의 조합으로 나타내는 방법은 다음과 같이 총 7가지가 있다.
1+1+1+1<br>
1+1+2<br>
1+2+1<br>
2+1+1<br>
2+2<br>
1+3<br>
3+1<br>
정수 n 이 입력으로 주어졌을 때, n을 1, 2, 3의 합으로 나타낼 수 있는 방법의 수를 구하시오.**
- - -
### Dynamic Programming(동적 계획법), Divide and Conquer(분할 정복)

- Dynamic Programming - DP
    - 입력 크기가 작은 부분 문제들을 해결 후, 해당 부분 문제의 해를 활용하여 보다 큰 크기의 부분 문제를 해결, 최종적으로 전체 문제를 해결하는 알고리즘
    **즉, 상향식 접근법으로, 가장 최하위 해답을 구한 후 이를 저장하고 해당 결과값을 이용해서 상위 문제를 풀어가는 방식**
    - Memorization 기법을 사용
        - 프로그램 실행 시 이전에 계산한 값을 저장하여 다시 계산하지 않도록 하여 전체 실행 속도를 빠르게 하는 기술
    - 문제를 잘게 나눌 때, 부분 문제는 중복되어 재활용 가능
        - EX. 피보나치 수열
- Divide and Conquer
    - 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘
    - 하향식 접근법으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식
        - 일반적으로 재귀함수로 구현
    - 문제를 잘게 나눌 때, 부분 문제는 서로 중복되지 않는다.
        - Ex. Merge Sort, Quick Sort

**공통점과 차이점**

- 공통점
    - 문제를 잘게 나누어, 가장 작은 단위로 분할
- 차이점
    - Dynamic Programming
        - 부분 문제는 중복(상위 문제 해결하면서 재활용)
        - Memorization 기법 사용 (재활용하여 최적화)
    - Divide and Conquer
        - 부분 문제는 중복 되지 않음
        - Memorization 기법 사용 안함
